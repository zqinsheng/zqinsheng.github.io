<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JasonZhou&#39;s Blog</title>
  
  <subtitle>Stay Hungry.  Stay Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zqinsheng.github.io/"/>
  <updated>2019-04-11T03:20:35.458Z</updated>
  <id>https://zqinsheng.github.io/</id>
  
  <author>
    <name>JasonZhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微信小程序-WXSS特性</title>
    <link href="https://zqinsheng.github.io/2019/04/10/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F06-WXSS%E7%89%B9%E6%80%A7/"/>
    <id>https://zqinsheng.github.io/2019/04/10/微信小程序06-WXSS特性/</id>
    <published>2019-04-10T14:55:46.000Z</published>
    <updated>2019-04-11T03:20:35.458Z</updated>
    
    <content type="html"><![CDATA[<p>在了解完小程序WXML模板之后，再来了解小程序视图层另外一门语言WXSS，WXSS（WeiXin Style Sheets）是一套用于小程序的样式语言，用于描述WXML的组件样式，也就是视觉上的效果。WXSS与Web开发中的CSS类似。为了更适合小程序开发，WXSS对CSS做了一些补充以及修改。<br>WXSS（WeiXin Style Sheets）:是一套样式语言，用于描述WXML的组件样式。<br>CSS（Cascading Style Sheets）：是一套样式语言，是一种样式表语言，用来描述HTML或XML文档的呈现。<br>熟悉CSS开发的朋友，上手WXSS会很快，WXSS在CSS的基础上做了补充和修改，方便小程序开发。<br><a id="more"></a></p><h3 id="尺寸单位"><a href="#尺寸单位" class="headerlink" title="尺寸单位"></a>尺寸单位</h3><p>在WXSS中，引入了rpx（responsive pixel）尺寸单位。也就是响应式像素，引用新尺寸单位的目的是，适配不同宽度的屏幕，开发起来更简单。<br>和常用的px像素单位相比，rpx像素在px上做了转换,小程序编译后，rpx会做一次px换算。换算是以375个物理像素为基准，也就是在一个宽度为375物理像素的屏幕下，1rpx = 1px。<br>例如：屏幕宽度为375px，共750个物理像素，那么1rpx = 375 / 750 px = 0.5px，px和rpx是1：2的对应关系。<br>在实际的开发中，根据屏幕的宽度来确定合适的rpx像素。  </p><h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p><strong>外联样式引用</strong><br>在小程序中可以通过<code>@import url(&#39;./test.css&#39;)</code>的方式来引入外部样式文件<br><strong>一个例子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text class=&apos;content&apos;&gt;hello world!&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// pages/wxml/index.wxss</span><br><span class="line">@import &apos;assets.wxss&apos;</span><br><span class="line">.content&#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// pages/wxml/assets.wxss</span><br><span class="line">.content&#123;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>界面显示效果：<br><img src="http://wx4.sinaimg.cn/mw690/007HSgDpgy1g1yii4me63j305100y0of.jpg" alt=""><br>hello world文字引用了两个样式文件中的效果！<br><strong>注意样式的执行顺序是从上到下，从左往右</strong>,顺序在后的样式会覆盖之前的样式。  </p><p><strong>内联样式</strong><br>内联样式和web开发中的css一致，在标签内部写样式即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view style=&quot;color: red; font-size: 20rpx&quot;&gt;hello&lt;/view&gt;</span><br></pre></td></tr></table></figure></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>WXSS选择器与CSS选择器类似,如下表所示:  </p><table><thead><tr><th>类型</th><th>选择器</th><th>样例</th><th>备注</th></tr></thead><tbody><tr><td>类选择器</td><td>.class</td><td>.content</td><td>选择所有拥有 class=”content” 的组件</td></tr><tr><td>id选择器</td><td>#id</td><td>#head-content</td><td>选择拥有 id=”head-content” 的组件</td></tr><tr><td>元素选择器</td><td>element</td><td>view checkbox</td><td>选择所有文档的 view 组件和所有的 checkbox 组件</td></tr><tr><td>伪元素选择器</td><td>::after</td><td>view::after</td><td>在 view 组件后边插入内容</td></tr><tr><td>伪元素选择器</td><td>::before</td><td>view::before</td><td>在 view 组件前边插入内容  </td></tr></tbody></table><p><strong>选择器优先级</strong><br>WXSS优先级与CSS类似,权重越高越优先。在优先级相同的情况下，后设置的样式优先级高于先设置的样式，根据权重的优先级加载样式。  </p><p><img src="http://wx4.sinaimg.cn/mw690/007HSgDpgy1g1yix0ojbaj30e8082gmy.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在了解完小程序WXML模板之后，再来了解小程序视图层另外一门语言WXSS，WXSS（WeiXin Style Sheets）是一套用于小程序的样式语言，用于描述WXML的组件样式，也就是视觉上的效果。WXSS与Web开发中的CSS类似。为了更适合小程序开发，WXSS对CSS做了一些补充以及修改。&lt;br&gt;WXSS（WeiXin Style Sheets）:是一套样式语言，用于描述WXML的组件样式。&lt;br&gt;CSS（Cascading Style Sheets）：是一套样式语言，是一种样式表语言，用来描述HTML或XML文档的呈现。&lt;br&gt;熟悉CSS开发的朋友，上手WXSS会很快，WXSS在CSS的基础上做了补充和修改，方便小程序开发。&lt;br&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-WXML特性之模板及引用</title>
    <link href="https://zqinsheng.github.io/2019/04/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F05-WXML%E7%89%B9%E6%80%A7%E4%B9%8B%E6%A8%A1%E6%9D%BF%E5%8F%8A%E5%BC%95%E7%94%A8/"/>
    <id>https://zqinsheng.github.io/2019/04/09/微信小程序05-WXML特性之模板及引用/</id>
    <published>2019-04-09T15:21:42.000Z</published>
    <updated>2019-04-10T14:10:33.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>WXML支持模板（template）的特性，可以在模板中定义代码片段，在不同的地方来调用或引入。使用name属性定义模板的名称，通过is名称来使用。<br>使用<code>&lt;template name=&quot;&quot;&gt;&lt;/template&gt;</code>定义模板<br>使用<code>&lt;template is=&quot;&quot; data=&quot;&quot;/&gt;</code>引用模板<br><a id="more"></a><br><strong>一个简单的例子</strong><br>定义模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=&quot;msgItem&quot;&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text&gt; 姓名:&#123;&#123;name&#125;&#125;，信息:&#123;&#123;msg&#125;&#125; &lt;/text&gt;</span><br><span class="line">    &lt;text&gt; 地址: &#123;&#123;address&#125;&#125; &lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>使用is属性，声明需要的使用的模板，然后将模板所需要的 data 传入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--  在js中对应的data</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    item: &#123;</span><br><span class="line">    name: &quot;小明&quot;,</span><br><span class="line">    msg: &apos;this is a student&apos;,</span><br><span class="line">    address: &apos;中国北京&apos;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;template name=&quot;msgItem&quot;&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text&gt; 姓名:&#123;&#123;name&#125;&#125;，信息:&#123;&#123;msg&#125;&#125; &lt;/text&gt;</span><br><span class="line">    &lt;text&gt; 地址: &#123;&#123;address&#125;&#125; &lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template is = &quot;msgItem&quot; data=&quot;&#123;&#123;...item&#125;&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 界面输出</span><br><span class="line">姓名：小明，信息：this is a student 地址：中国北京</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><p><strong>动态使用模板</strong><br>is可以动态决定具体需要渲染哪个模板<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template name=&quot;odd&quot;&gt;</span><br><span class="line">  &lt;view&gt; odd &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;template name=&quot;even&quot;&gt;</span><br><span class="line">  &lt;view&gt; even &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;block wx:for=&quot;&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;template is=&quot;&#123;&#123;item % 2 == 0 ? &apos;even&apos; : &apos;odd&apos;&#125;&#125;&quot;/&gt;</span><br><span class="line">&lt;/block&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!-- 输出</span><br><span class="line">odd</span><br><span class="line">even</span><br><span class="line">odd</span><br><span class="line">even</span><br><span class="line">odd</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><p><strong>模板引用</strong><br>WXML 提供两种文件引用方式import和include。<br>我们来看一下这两种引用方式的区别：<br>首先，新建一个模板页面template<br><img src="http://wx3.sinaimg.cn/mw690/007HSgDpgy1g1xvbner9sj306w038743.jpg" alt=""><br>template.wxml文件中定义一个模板:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/template/template.wxml--&gt;</span><br><span class="line">&lt;text&gt;pages/template/template.wxml&lt;/text&gt;</span><br><span class="line">&lt;template name=&quot;templatePerson&quot;&gt;</span><br><span class="line">  &lt;view&gt;</span><br><span class="line">    &lt;text&gt;我是模板一&lt;/text&gt;</span><br><span class="line">  &lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p><p>template.js中设置内部状态变量person:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  person:&#123;</span><br><span class="line">    name:&quot;老张&quot;,</span><br><span class="line">    age:18,</span><br><span class="line">    phone:&quot;13212332112&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>使用import的方式来引入模板</strong><br>在index.wxml文件中引入上面定义的模板：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;!--只会 import 目标文件中定义的 template--&gt;</span><br><span class="line">&lt;import src=&quot;../template/template.wxml&quot;/&gt;</span><br><span class="line">&lt;template is=&quot;templatePerson&quot; data=&quot;&#123;&#123;...peoson&#125;&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--在界面上输出</span><br><span class="line">    我是模板一</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><p><strong>使用include的方式来引入模板</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;include src=&quot;../template/template.wxml&quot;/&gt;</span><br><span class="line">&lt;template is=&quot;templatePerson&quot; data=&quot;&#123;&#123;...peoson&#125;&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--在界面上输出</span><br><span class="line">    pages/template/template.wxml</span><br><span class="line">    我是模板一</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></p><p><strong>总结:</strong>  1.使用import方式只会引用目标文件中定义的template。2.include 可以将目标文件中除了将template引入，还会把整个代码引入，相当于是把代码拷贝到 include 的位置。</p><p><strong>注意事项</strong><br>import不具有递归特性，例如：有三个模板A，B，C。<br>C 引用 B，B 引用A，在C中可以使用B定义的 template，在B中可以使用A定义的 template ，但是C不能使用A定义的template</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;模板&quot;&gt;&lt;a href=&quot;#模板&quot; class=&quot;headerlink&quot; title=&quot;模板&quot;&gt;&lt;/a&gt;模板&lt;/h2&gt;&lt;p&gt;WXML支持模板（template）的特性，可以在模板中定义代码片段，在不同的地方来调用或引入。使用name属性定义模板的名称，通过is名称来使用。&lt;br&gt;使用&lt;code&gt;&amp;lt;template name=&amp;quot;&amp;quot;&amp;gt;&amp;lt;/template&amp;gt;&lt;/code&gt;定义模板&lt;br&gt;使用&lt;code&gt;&amp;lt;template is=&amp;quot;&amp;quot; data=&amp;quot;&amp;quot;/&amp;gt;&lt;/code&gt;引用模板&lt;br&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-WXML特性之条件渲染和列表渲染</title>
    <link href="https://zqinsheng.github.io/2019/04/09/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F04-WXML%E7%89%B9%E6%80%A7%E4%B9%8B%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E5%92%8C%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/"/>
    <id>https://zqinsheng.github.io/2019/04/09/微信小程序04-WXML特性之条件渲染和列表渲染/</id>
    <published>2019-04-09T13:55:12.000Z</published>
    <updated>2019-04-10T09:00:56.751Z</updated>
    
    <content type="html"><![CDATA[<h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>界面上的数据可以通过条件判断的方式来动态显示<br>语法为：<code>wx:if</code><br>使用 wx:elif：<code>wx:elif=&quot;&quot;</code> 和 wx:else: <code>wx:else</code><br><a id="more"></a><br><strong>一个简单的例子</strong><br>根据条件选择今天吃啥，条件是1吃米饭，条件是2吃面条，其他条件吃米线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text wx:if=&quot;&#123;&#123;condition==1&#125;&#125;&quot;&gt;</span><br><span class="line">    米饭</span><br><span class="line">  &lt;/text&gt;</span><br><span class="line">    &lt;text wx:elif=&quot;&#123;&#123;condition==2&#125;&#125;&quot;&gt;</span><br><span class="line">    面条</span><br><span class="line">  &lt;/text&gt;</span><br><span class="line">      &lt;text wx:else&gt;</span><br><span class="line">    米线</span><br><span class="line">  &lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// pages/wxml/index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    //随机生成1，2，3的数字</span><br><span class="line">     condition:Math.floor(Math.random()*3+1)</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></p><p><strong>条件渲染和hidden的区别</strong><br>使用条件渲染和改变标签的hidden属性都可以控制元素的显示，而hidden属性始终都会渲染出元素块，只是控制显示与否。hidden在界面初始化的时候会有更高的初始化消耗。<br>wx:if在切换时框架会进行局部渲染，保证元素块在销毁时会进行重新渲染，在切换时消耗更高。<br>根据场景情况，在元素频繁切换显示时建议使用hidden进行条件渲染。  </p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>在我们的界面当中，如果内容比较少，我们可以一条一条的显示内容，但是当内容是一个整体或是一堆数据的时候，我们显示和更改就很麻烦，这个时候就可以用到小程序wxml的另外一个特性-列表渲染。<br>在组件上使用 <code>wx:for={数组名}}</code> 控制属性绑定一个数组或列表，即可使用各项数据渲染界面，<strong>默认的下标变量名为index，默认的当前项变量名为item</strong><br><strong>一个简单的例子</strong><br>比如说渲染出一组学生的姓名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;names&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;!--默认下标索引名index，默认当前项名item--&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;index&#125;&#125;&#123;item.name&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    names:[</span><br><span class="line">      &#123;name:&quot;张三&quot;&#125;,</span><br><span class="line">      &#123;name:&quot;李四&quot;&#125;,</span><br><span class="line">      &#123;name:&quot;王五&quot;&#125;,</span><br><span class="line">      &#123;name:&quot;赵六&quot;&#125;</span><br><span class="line">    ],</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">      &lt;!--</span><br><span class="line">        在界面上显示：</span><br><span class="line">        0张三</span><br><span class="line">        1李四</span><br><span class="line">        2王五</span><br><span class="line">        3赵六</span><br><span class="line">      --&gt;</span><br></pre></td></tr></table></figure></p><p><strong>使用 wx:for-item 指定数组当前元素的变量名，使用 wx:for-index 指定数组当前下标的变量名：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view wx:for=&quot;&#123;&#123;names&#125;&#125;&quot; wx:for-item=&quot;n&quot; wx:for-index=&quot;i&quot;&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;i&#125;&#125;&#123;n.name&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;条件渲染&quot;&gt;&lt;a href=&quot;#条件渲染&quot; class=&quot;headerlink&quot; title=&quot;条件渲染&quot;&gt;&lt;/a&gt;条件渲染&lt;/h3&gt;&lt;p&gt;界面上的数据可以通过条件判断的方式来动态显示&lt;br&gt;语法为：&lt;code&gt;wx:if&lt;/code&gt;&lt;br&gt;使用 wx:elif：&lt;code&gt;wx:elif=&amp;quot;&amp;quot;&lt;/code&gt; 和 wx:else: &lt;code&gt;wx:else&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-WXML特性之数据绑定</title>
    <link href="https://zqinsheng.github.io/2019/04/07/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F03-WXML%E7%89%B9%E6%80%A7%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <id>https://zqinsheng.github.io/2019/04/07/微信小程序03-WXML特性之数据绑定/</id>
    <published>2019-04-07T15:25:25.000Z</published>
    <updated>2019-04-09T14:06:02.223Z</updated>
    
    <content type="html"><![CDATA[<p>在对用户呈现的界面中，用户所看到的内容往往会随着操作的数据不同而不同，这就要求界面呈现给用户的东西要动态变化，界面要随着用户的操作动态渲染，这就要求我们要有动态去改变界面的能力。在小程序中，通过WXML的数据绑定功能可以动态的渲染界面。<br><a id="more"></a></p><h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><p>页面上的动态数据都来自于对应页面JS文件中Page()函数的data对象,而我们绑定数据用的是mustache语法:<strong></strong>，通过这样的方式就可以取到对应变量的值。<br>wxml可以绑定文本、数字、布尔等类型的值<br>例如:在index.wxml和index.js中加入如下代码，我们依然可以在界面中显示hello world，当message对应的变量值改变的时候，界面上呈现的值也会随之改变：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;text&gt;信息：&#123;&#123;message&#125;&#125;&lt;/text&gt;</span><br><span class="line"></span><br><span class="line">// pages/wxml/index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">   message:&quot;hello world&quot;</span><br><span class="line"> &#125;)</span><br><span class="line"></span><br><span class="line">      &lt;!-- 输出 hello world --&gt;</span><br></pre></td></tr></table></figure></p><h4 id="绑定标签属性值"><a href="#绑定标签属性值" class="headerlink" title="绑定标签属性值"></a>绑定标签属性值</h4><p>wxml不仅可以绑定文本的值，还可以动态绑定标签的属性值<br>例如：我们自定义一个属性data-name为它绑定值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">&lt;text data-name=&quot;&#123;&#123;dataName&#125;&#125;&quot;&gt;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// pages/wxml/index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">   dataName:&quot;jason&quot;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p><em>这里特别注意我们所有的属性和组件都要求用小写</em>  </p><h4 id="逻辑语法"><a href="#逻辑语法" class="headerlink" title="逻辑语法"></a>逻辑语法</h4><p><strong>三元运算</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;a&gt;1 ? &quot;a大于1&quot; : &quot;a小于1&quot;&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// pages/wxml/index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">  a:3</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">    &lt;!-- 输出 a大于1 --&gt;</span><br></pre></td></tr></table></figure></p><p><strong>算术运算</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;a+b&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// pages/wxml/index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">  a:3,</span><br><span class="line">  b:2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">      &lt;!-- 输出 5 --&gt;</span><br></pre></td></tr></table></figure></p><p><strong>字符串拼接</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--pages/wxml/index.wxml--&gt;</span><br><span class="line">&lt;view&gt;</span><br><span class="line">  &lt;text&gt;&#123;&#123;msg+&quot; world&quot;&#125;&#125;&lt;/text&gt;</span><br><span class="line">&lt;/view&gt;</span><br><span class="line"></span><br><span class="line">// pages/wxml/index.js</span><br><span class="line">Page(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    msg:&quot;hello&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">     &lt;!-- 输出 hello world --&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在对用户呈现的界面中，用户所看到的内容往往会随着操作的数据不同而不同，这就要求界面呈现给用户的东西要动态变化，界面要随着用户的操作动态渲染，这就要求我们要有动态去改变界面的能力。在小程序中，通过WXML的数据绑定功能可以动态的渲染界面。&lt;br&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-开发框架组成</title>
    <link href="https://zqinsheng.github.io/2019/04/02/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F02-%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6%E7%BB%84%E6%88%90/"/>
    <id>https://zqinsheng.github.io/2019/04/02/微信小程序02-开发框架组成/</id>
    <published>2019-04-02T12:15:12.000Z</published>
    <updated>2019-04-08T06:59:13.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序代码组成"><a href="#小程序代码组成" class="headerlink" title="小程序代码组成"></a>小程序代码组成</h2><p>在我们新建好一个小程序项目后，开发工具帮我们把基本的结构目录搭建好了，我们不难发现，在每一个文件夹下面都有四个文件，每一个页面都对应着四个文件<br><img src="http://wx1.sinaimg.cn/mw690/007HSgDpgy1g1oo9naxkyj308307ia9y.jpg" alt="">  </p><p>这些文件就是小程序的组成元素,小程序由 配置代码JSON文件、模板代码 WXML 文件、样式代码 WXSS文件以及逻辑代码 JavaScript文件组成。每一个文件都发挥着各自的作用，下面来详细介绍每一个文件所扮演的角色。  </p><h2 id="一、WXML-模板"><a href="#一、WXML-模板" class="headerlink" title="一、WXML 模板"></a>一、WXML 模板</h2><p>WXML 全称是 WeiXin Markup Language，是小程序框架设计的一套标签语言，结合小程序的各种组件渲染出页面的结构。<strong>语法和HTML类似</strong>，有过HTML开发经验应该可以很快上手，它也是通过标签来渲染视图的，基本语法如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 在此处写注释 --&gt;</span><br><span class="line"></span><br><span class="line">&lt;标签名 属性名1=&quot;属性值1&quot; 属性名2=&quot;属性值2&quot; ...&gt; ...&lt;/标签名&gt;</span><br></pre></td></tr></table></figure></p><ul><li>标签拥有一些共同属性  </li></ul><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>组件的唯一标识</td><td>在整个页面唯一</td></tr><tr><td>class</td><td>String</td><td>组件的样式类</td><td>在对应的 WXSS 中定义的样式类</td></tr><tr><td>style</td><td>String</td><td>组件的内联样式</td><td>可以动态设置的内联样式</td></tr><tr><td>hidden</td><td>Boolean</td><td>组件是否显示</td><td>所有组件默认显示</td></tr><tr><td>data-*</td><td>Any</td><td>自定义属性</td><td>组件上触发的事件时，会发送给事件处理函数</td></tr><tr><td>bind<em>/catch</em></td><td>EventHandler</td><td>组件的事件</td><td></td></tr></tbody></table><a id="more"></a><ul><li>标签自定义属性  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view test-data-name=&quot;hello&quot;&gt; &lt;/view&gt;</span><br></pre></td></tr></table></figure></li></ul><p>我们为view标签自定义了一个test-data-name的属性，它的值为hello  </p><ul><li>注意事项  </li></ul><p>​一个完整的 WXML语句由一段开始标签和一段结束标签组成，WXML 要求标签必须是严格闭合的，没有闭合将会导致编译错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">text 没有闭合，导致编译错误：</span><br><span class="line">expect end-tag `text`., near `view`</span><br><span class="line">    |   &lt;view&gt;</span><br><span class="line">    |     &lt;text&gt;hello world</span><br><span class="line">    |   &lt;/view&gt;</span><br><span class="line">    |    ^</span><br><span class="line">    | &lt;/view&gt;</span><br></pre></td></tr></table></figure></p><h2 id="二、WXSS-样式"><a href="#二、WXSS-样式" class="headerlink" title="二、WXSS 样式"></a>二、WXSS 样式</h2><p>WXSS（WeiXin Style Sheets）是一套用于小程序的样式语言，用于描述WXML的组件样式，也就是视觉上的效果。WXSS与Web开发中的CSS类似。为了更适合小程序开发，WXSS对CSS做了一些补充以及修改。熟悉web开发的朋友对WXSS也应该很快就上手。  </p><ul><li><p>项目公共样式<br><img src="http://wx3.sinaimg.cn/mw690/007HSgDpgy1g1qlbfsuawj30d7065q2z.jpg" alt=""><br>在项目根目录下，可以看到一个app.wxss文件，这个文件为项目公共样式，在这个页面里面写的样式会被注入到小程序的每个页面，对其每一个页面都生效。  </p></li><li><p>其他样式<br><img src="http://wx3.sinaimg.cn/mw690/007HSgDpgy1g1qlbj7ud8j307s09l3yi.jpg" alt=""><br>每个页面对应的样式文件，也可以被其它样式或公共样式引用  </p></li></ul><h2 id="三、JavaScript-脚本"><a href="#三、JavaScript-脚本" class="headerlink" title="三、JavaScript 脚本"></a>三、JavaScript 脚本</h2><p>小程序的主要开发语言是 JavaScript ，开发者使用 JavaScript 来开发业务逻辑以及调用小程序的 API 来完成业务需求。  </p><h2 id="四、JSON-配置文件"><a href="#四、JSON-配置文件" class="headerlink" title="四、JSON 配置文件"></a>四、JSON 配置文件</h2><p>JSON(JavaScript Object Notation, JS 对象简谱) 是一种轻量级的数据交换格式，它不是一种编程语言，它在小程序中扮演着静态配置的作用，简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。  </p><p> Json文件同样分为两种:<strong>1.全局Json配置文件 2、单一页面Json配置文件</strong>。全局Json配置文件在项目根目录下，单一页面的Json配置文件在每个页面文件夹下。  </p><p> 我们可以更改全局Json配置文件，改变界面的总体设置<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  &quot;pages&quot;:[</span><br><span class="line">    &quot;pages/index/index&quot;,</span><br><span class="line">    &quot;pages/logs/logs&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;window&quot;:&#123;</span><br><span class="line">    &quot;backgroundTextStyle&quot;:&quot;light&quot;,</span><br><span class="line">    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line">    &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,</span><br><span class="line">    &quot;navigationBarTextStyle&quot;:&quot;black&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试更改项目启动的默认页面：<br>项目中的所有页面都要在”pages”中注册<br>在pages数组中，放在第一个位置的页面会被默认加载<br>所以我们启动小程序默认是显示pages/index/index的页面<br>可以更改顺序，把”pages/logs/logs”放到”pages/index/index”前面，改变默认加载log页面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;pages&quot;:[</span><br><span class="line">   &quot;pages/logs/logs&quot;,</span><br><span class="line">   &quot;pages/index/index&quot;</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure></p><p>也可以尝试更改界面配置参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;window&quot;:&#123;</span><br><span class="line">  //动态设置下拉背景字体、loading 图的样式,仅支持dark和light</span><br><span class="line">  &quot;backgroundTextStyle&quot;:&quot;light&quot;,</span><br><span class="line"></span><br><span class="line">  //设置导航栏的背景颜色</span><br><span class="line">  &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,</span><br><span class="line"></span><br><span class="line">  //设置导航栏的文字</span><br><span class="line">  &quot;navigationBarTitleText&quot;: &quot;WeChat&quot;,</span><br><span class="line"></span><br><span class="line">  //设置导航栏的字体颜色，仅支持black和write</span><br><span class="line">  &quot;navigationBarTextStyle&quot;:&quot;black&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>特别注意：JSON配置文件中不能使用注释，否则会报错!</strong>  </p><h3 id="JSON语法"><a href="#JSON语法" class="headerlink" title="JSON语法"></a>JSON语法</h3><p>相比于XML ，JSON格式最大的优点是易于人的阅读和编写，通常不需要特殊的工具，就能读懂和修改，是一种轻量级的数据交换格式。</p><p>JSON文件都是被包裹在一个大括号中 {}，通过key-value的方式来表达数据。一般形式为 <strong>键:值</strong>  </p><p>JSON 语法是 JavaScript 对象表示语法的子集。</p><ul><li>数据在名称/值对中</li><li>数据由逗号分隔</li><li>大括号保存对象</li><li>中括号保存数组  </li></ul><p>JSON 值可以是：</p><ul><li>数字（整数或浮点数）</li><li>字符串（在双引号中）</li><li>逻辑值（true 或 false）</li><li>数组（在中括号中）</li><li>对象（在大括号中）</li><li>null  </li></ul><h3 id="JSON-数字"><a href="#JSON-数字" class="headerlink" title="JSON 数字"></a>JSON 数字</h3><p>JSON 数字可以是整型或者浮点型：<br>存储年龄为30:<br><code>{ &quot;age&quot;:30 }</code></p><h3 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p>JSON 对象在大括号（{}）中书写：<br>对象可以包含多个名称/值对：<br>存储小明这个对象:<br><code>{ &quot;name&quot;:&quot;小明&quot; , &quot;age&quot;:18,&quot;gender&quot;:&quot;男&quot;}</code></p><h3 id="JSON-数组"><a href="#JSON-数组" class="headerlink" title="JSON 数组"></a>JSON 数组</h3><p>JSON 数组在中括号中书写：<br>数组可包含多个<strong>对象</strong>：<br>存储三个学生的信息：  </p><pre><code class="json">{<span class="attr">"student"</span>: [{ <span class="attr">"name"</span>:<span class="string">"小明"</span> , <span class="attr">"age"</span>:<span class="number">18</span> },{ <span class="attr">"name"</span>:<span class="string">"小王"</span> , <span class="attr">"age"</span>:<span class="number">20</span> },{ <span class="attr">"name"</span>:<span class="string">"小小李"</span> , <span class="attr">"age"</span>:<span class="number">19</span> }]}</code></pre><h3 id="JSON-布尔值"><a href="#JSON-布尔值" class="headerlink" title="JSON 布尔值"></a>JSON 布尔值</h3><p>JSON 布尔值可以是 true 或者 false：<code>{ &quot;flag&quot;:true }</code>  </p><h3 id="JSON-null"><a href="#JSON-null" class="headerlink" title="JSON null"></a>JSON null</h3><p>JSON 可以设置 null 值：<code>address:null</code></p><p>如果对json语法陌生的，请先学习json语法！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;小程序代码组成&quot;&gt;&lt;a href=&quot;#小程序代码组成&quot; class=&quot;headerlink&quot; title=&quot;小程序代码组成&quot;&gt;&lt;/a&gt;小程序代码组成&lt;/h2&gt;&lt;p&gt;在我们新建好一个小程序项目后，开发工具帮我们把基本的结构目录搭建好了，我们不难发现，在每一个文件夹下面都有四个文件，每一个页面都对应着四个文件&lt;br&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/007HSgDpgy1g1oo9naxkyj308307ia9y.jpg&quot; alt=&quot;&quot;&gt;  &lt;/p&gt;
&lt;p&gt;这些文件就是小程序的组成元素,小程序由 配置代码JSON文件、模板代码 WXML 文件、样式代码 WXSS文件以及逻辑代码 JavaScript文件组成。每一个文件都发挥着各自的作用，下面来详细介绍每一个文件所扮演的角色。  &lt;/p&gt;
&lt;h2 id=&quot;一、WXML-模板&quot;&gt;&lt;a href=&quot;#一、WXML-模板&quot; class=&quot;headerlink&quot; title=&quot;一、WXML 模板&quot;&gt;&lt;/a&gt;一、WXML 模板&lt;/h2&gt;&lt;p&gt;WXML 全称是 WeiXin Markup Language，是小程序框架设计的一套标签语言，结合小程序的各种组件渲染出页面的结构。&lt;strong&gt;语法和HTML类似&lt;/strong&gt;，有过HTML开发经验应该可以很快上手，它也是通过标签来渲染视图的，基本语法如下:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;!-- 在此处写注释 --&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;标签名 属性名1=&amp;quot;属性值1&amp;quot; 属性名2=&amp;quot;属性值2&amp;quot; ...&amp;gt; ...&amp;lt;/标签名&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标签拥有一些共同属性  &lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;备注&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;组件的唯一标识&lt;/td&gt;
&lt;td&gt;在整个页面唯一&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;class&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;组件的样式类&lt;/td&gt;
&lt;td&gt;在对应的 WXSS 中定义的样式类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;style&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;组件的内联样式&lt;/td&gt;
&lt;td&gt;可以动态设置的内联样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hidden&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;td&gt;组件是否显示&lt;/td&gt;
&lt;td&gt;所有组件默认显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;data-*&lt;/td&gt;
&lt;td&gt;Any&lt;/td&gt;
&lt;td&gt;自定义属性&lt;/td&gt;
&lt;td&gt;组件上触发的事件时，会发送给事件处理函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;bind&lt;em&gt;/catch&lt;/em&gt;&lt;/td&gt;
&lt;td&gt;EventHandler&lt;/td&gt;
&lt;td&gt;组件的事件&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序-Hello World</title>
    <link href="https://zqinsheng.github.io/2019/04/01/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F01-hello%20world/"/>
    <id>https://zqinsheng.github.io/2019/04/01/微信小程序01-hello world/</id>
    <published>2019-04-01T12:15:38.000Z</published>
    <updated>2019-04-04T08:29:13.036Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发前的准备"><a href="#开发前的准备" class="headerlink" title="开发前的准备"></a>开发前的准备</h2><ol><li>前往微信公众平台注册AppId( <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a>)  </li></ol><p><img src="http://wx4.sinaimg.cn/mw690/007HSgDpgy1g1om3x96ioj30mg0gtq9w.jpg" alt=""><br><a id="more"></a></p><p>填写邮箱等相关信息注册小程序<br><img src="http://wx3.sinaimg.cn/mw690/007HSgDpgy1g1om0o6lhcj30j10gddg9.jpg" alt="">  </p><p>注册成功之后用微信关联登录，便可进入小程序的后台管理界面，在开发-开发设置-开发者ID中可以看到AppID(小程序ID),注册完成之后下载开发工具<br><img src="http://wx4.sinaimg.cn/mw690/007HSgDpgy1g1omi5p9poj310s0hg0ti.jpg" alt=""></p><ol><li><p>开发工具下载（<a href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html" target="_blank" rel="noopener">点击这里下载</a>）  </p></li><li><p>新建项目<br>安装好微信Web开发工具，新建一个小程序的项目，填写项目名称选择路径之后填写AppID，这里不使用云服务进行开发<br><img src="http://wx4.sinaimg.cn/mw690/007HSgDpgy1g1omzgnlr6j30mn0fezl4.jpg" alt="">  </p></li></ol><p>新建完之后，小程序已经把基本的项目结构给我们搭建好了，我们可以可以找到项目路径下pages/index/index.wxml页面更改相应的代码，就可以在左边模拟器屏幕上显示hello world<br><img src="http://wx3.sinaimg.cn/mw690/007HSgDpgy1g1on99seg3j30us0j9dhq.jpg" alt="">  </p><p>也可以通过真机调试的功能，编译出一个二维码，用手机微信扫码之后在真机上看界面详情<br><img src="http://wx2.sinaimg.cn/mw690/007HSgDpgy1g1ondkeyodj30m50ckabg.jpg" alt=""><br>至此，一个简单的hello world程序就写好了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;开发前的准备&quot;&gt;&lt;a href=&quot;#开发前的准备&quot; class=&quot;headerlink&quot; title=&quot;开发前的准备&quot;&gt;&lt;/a&gt;开发前的准备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;前往微信公众平台注册AppId( &lt;a href=&quot;https://mp.weixin.qq.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mp.weixin.qq.com/&lt;/a&gt;)  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://wx4.sinaimg.cn/mw690/007HSgDpgy1g1om3x96ioj30mg0gtq9w.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="https://zqinsheng.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop RPC实现机制</title>
    <link href="https://zqinsheng.github.io/2018/02/02/06_Hadoop%20RPC%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <id>https://zqinsheng.github.io/2018/02/02/06_Hadoop RPC实现机制/</id>
    <published>2018-02-01T16:22:34.000Z</published>
    <updated>2018-08-14T18:56:53.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、RPC基础概念"><a href="#一、RPC基础概念" class="headerlink" title="一、RPC基础概念"></a>一、RPC基础概念</h2><p>RPC 是Remote Procedure Call（远程过程调用）的简写，是一种通过网络从远程计算机上请求服务的机制，封装了具体实现，使用户不需要了解底层网络技术。<br>RPC采用客户机/服务器模式,主要应用于一些分布式的系统，客户机上的一个请求程序,调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息的到达为止。当一个调用信息到达，服务器获得进程参数，根据参数作出答复，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。用简单的话说，就是一台计算机程序远程调用另外一台计算机的程序。<br>RPC对于我们来说是透明的，在调用的过程中感觉不到其间涉及跨机器间的通信，而是感觉像是在执行一个本地调用。我们不用去关心底层的网络通信细节，这是RPC中的访问透明性。  </p><p><img src="http://wx3.sinaimg.cn/large/005TBZ5oly1fo8cmi1hldj30kx0beq4i.jpg" alt=""></p><ol><li>通信模块：客户端与服务的的请求应答消息，TCP/IP的socket机制</li><li>stub程序：代理程序，为了保证RPC的透明性，它在客户端表现的就像调用本地程序一样，客户端发送请求参数之后，服务器端stub程序会解码对应结果、调用相应的服务过程返回结果给服务端。</li><li>客户端/服务端过程：即请求的发出者与请求的处理者</li><li>调度程序：调度程序接受来自通信模块的请求消息，并根据其中的标识选择一个Stub程序进行处理。</li></ol><a id="more"></a><h2 id="二、Hadoop中RPC的Demo"><a href="#二、Hadoop中RPC的Demo" class="headerlink" title="二、Hadoop中RPC的Demo"></a>二、Hadoop中RPC的Demo</h2><p>hadoop 的 common 包中包含有 RPC 的包，有了这个 RPC 的包才能进行 RPC 操作，通过一个demo程序来感受一下RPC。<br>模拟用户登陆成功：从客户端调用远程服务端的登陆方法，登陆成功并返回登陆结果。</p><table><thead><tr><th></th><th>客户端</th><th>服务端</th></tr></thead><tbody><tr><td>环境</td><td>win10/eclipse</td><td>centerOS/eclipse</td></tr><tr><td>网络配置</td><td>暂时用不到</td><td>主机名：master(192.168.2.100)</td></tr><tr><td>项目详情</td><td><img src="http://wx1.sinaimg.cn/large/005TBZ5oly1fobqv7gk48j306r043a9y.jpg" alt=""></td><td><img src="http://wx4.sinaimg.cn/large/005TBZ5oly1fobqq0xd7bj308w05cweg.jpg" alt=""></td></tr></tbody></table><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p><strong> 1.定义一个LoginService协议接口 </strong><br>RPC通信是通过 client 和 server 之间的接口通信，定义 server 对外服务的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义协议版本号，通过这个版本号来确认client和server之间的通信，不同版本号之间不能相互通信</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> versionID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 2.定义LoginService的实现：LoginServiceImpl </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServiceImpl</span> <span class="keyword">implements</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username+<span class="string">" is login !"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 3.构造并启动RPC server </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Start</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> HadoopIllegalArgumentException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//创建RPC.Builder实例，设置一些必要的参数</span></span><br><span class="line">Builder builder = <span class="keyword">new</span> RPC.Builder(<span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="comment">//设置主机名</span></span><br><span class="line">builder.setBindAddress(<span class="string">"master"</span>);</span><br><span class="line">    <span class="comment">//设置端口号</span></span><br><span class="line">    builder.setPort(<span class="number">6666</span>);</span><br><span class="line">    <span class="comment">//协议接口</span></span><br><span class="line">    builder.setProtocol(LoginService.class);</span><br><span class="line">    <span class="comment">//业务逻辑实例</span></span><br><span class="line">    builder.setInstance(<span class="keyword">new</span> LoginServiceImpl());</span><br><span class="line"><span class="comment">//构造RPC Server实例</span></span><br><span class="line">Server server = builder.build();</span><br><span class="line">    <span class="comment">//启动服务，处于监听状态</span></span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p><strong> 1.将服务端的 LoginService 协议接口拷贝到客户端中 </strong></p><p><img src="http://wx1.sinaimg.cn/large/005TBZ5oly1fobqv7gk48j306r043a9y.jpg" alt=""></p><p>注意客户端中的 LoginService 同样需要定义协议版本号并与服务端保持一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> versionID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong> 2.调用服务端的login方法 </strong></p><p>客户端代码的核心在于RPC.getProxy()，它可以返回一个代理对象，这个代码对象就是服务器端对象的代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      通过RPC拿到代理对象</span></span><br><span class="line"><span class="comment">      RPC.getProxy(协议接口, 版本号, 通信地址:主机名，端口号 , 配置信息);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">LoginService proxy = RPC.getProxy(LoginService.class, <span class="number">1L</span>, <span class="keyword">new</span> InetSocketAddress(<span class="string">"master"</span>, <span class="number">6666</span>), <span class="keyword">new</span> Configuration());</span><br><span class="line">    <span class="comment">//调用login方法,就像调用本地方法一样</span></span><br><span class="line">String loginUser = proxy.login(<span class="string">"JasonZhou"</span>);</span><br><span class="line">System.out.println(loginUser);</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    RPC.stopProxy(proxy);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行成功，在控制台看到输出信息，调用远程方法成功 ！<br><code>JasonZhou is login !</code></p><p>整个过程如下图所示<br><img src="http://wx1.sinaimg.cn/large/005TBZ5oly1fobst8xn04j31kw0qgqv5.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、RPC基础概念&quot;&gt;&lt;a href=&quot;#一、RPC基础概念&quot; class=&quot;headerlink&quot; title=&quot;一、RPC基础概念&quot;&gt;&lt;/a&gt;一、RPC基础概念&lt;/h2&gt;&lt;p&gt;RPC 是Remote Procedure Call（远程过程调用）的简写，是一种通过网络从远程计算机上请求服务的机制，封装了具体实现，使用户不需要了解底层网络技术。&lt;br&gt;RPC采用客户机/服务器模式,主要应用于一些分布式的系统，客户机上的一个请求程序,调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息的到达为止。当一个调用信息到达，服务器获得进程参数，根据参数作出答复，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。用简单的话说，就是一台计算机程序远程调用另外一台计算机的程序。&lt;br&gt;RPC对于我们来说是透明的，在调用的过程中感觉不到其间涉及跨机器间的通信，而是感觉像是在执行一个本地调用。我们不用去关心底层的网络通信细节，这是RPC中的访问透明性。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx3.sinaimg.cn/large/005TBZ5oly1fo8cmi1hldj30kx0beq4i.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通信模块：客户端与服务的的请求应答消息，TCP/IP的socket机制&lt;/li&gt;
&lt;li&gt;stub程序：代理程序，为了保证RPC的透明性，它在客户端表现的就像调用本地程序一样，客户端发送请求参数之后，服务器端stub程序会解码对应结果、调用相应的服务过程返回结果给服务端。&lt;/li&gt;
&lt;li&gt;客户端/服务端过程：即请求的发出者与请求的处理者&lt;/li&gt;
&lt;li&gt;调度程序：调度程序接受来自通信模块的请求消息，并根据其中的标识选择一个Stub程序进行处理。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>HDFS的JAVA客户端编写</title>
    <link href="https://zqinsheng.github.io/2018/01/20/05_hdfs%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E5%86%99/"/>
    <id>https://zqinsheng.github.io/2018/01/20/05_hdfs的java客户端编写/</id>
    <published>2018-01-20T12:15:12.000Z</published>
    <updated>2019-04-08T06:52:12.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HDFS的JAVA客户端编写"><a href="#HDFS的JAVA客户端编写" class="headerlink" title="HDFS的JAVA客户端编写"></a>HDFS的JAVA客户端编写</h1><p>之前一直使用 HDFS Shell 命令来完成对 HDFS 的操作，当然也可以使用 Java 来对 HDFS 实现操作。<br>接下来通过一些例子来看一下 JAVA 是如何对 HDFS 实现操作的。  </p><h3 id="在eclipse中新建一个java项目"><a href="#在eclipse中新建一个java项目" class="headerlink" title="在eclipse中新建一个java项目"></a>在eclipse中新建一个java项目</h3><p>将Linux中hadoop安装目录下，配置好的<code>core-site.xml</code> <code>hdfs-site.xml</code>，mapred-site.xml，yarn-site.xml都拷贝到eclipse工作空间<br><img src="http://wx2.sinaimg.cn/large/005TBZ5oly1fo4ufraku9j309c05t0sq.jpg" alt=""><br><a id="more"></a><br>要对hdfs进行操作，需要两个核心jar包，这两个jar包可以在hadoop安装包中找到（hadoop-x.x.x\share\hadoop），导入这两个文件夹中对应的jar包以及他们的依赖包(在这两个目录下面的lib文件夹中)<br><img src="http://wx4.sinaimg.cn/large/005TBZ5oly1fo9isn3lvqj304m01b0s3.jpg" alt=""><br>将这两个jar包导入到项目中<br><img src="http://wx1.sinaimg.cn/large/005TBZ5oly1fo4uamux7xj30r90fn75r.jpg" alt=""></p><p>或通过maven，添加相应版本的依赖</p><p>pom.xml中加入这两个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- hadoop hdfs类库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-hdfs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- hadoop 公共类库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.hadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hadoop-common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="访问HDFS的两种方式"><a href="#访问HDFS的两种方式" class="headerlink" title="访问HDFS的两种方式"></a>访问HDFS的两种方式</h3><p>访问 HDFS 的核心类是<strong>FileSystem</strong>，<strong>FileSystem</strong> 是文件系统的抽象，HDFS是分布式文件系统对 <strong>FileSystem</strong> 的实现，<strong>FileSystem</strong> 有很多文件系统的实现，不论底层文件系统的具体实现是什么样的，文件系统 <strong>FileSystem</strong> 统一提供了访问接口，直接通过 <strong>FileSystem</strong> 来进行操作，如此即可解耦合。<br>如下是 <strong>FileSystem</strong> 的继承关系：  </p><p><img src="http://wx3.sinaimg.cn/large/005TBZ5oly1fo8d68895jj30jj0e9t9k.jpg" alt=""></p><p><strong>通过FileSystem访问HDFS</strong></p><ol><li><p>设置默认配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方式1：</span></span><br><span class="line"><span class="comment">默认读取classpath下的xxx.site.xml配置文件，并解析其内容，封装到conf对象中。</span></span><br><span class="line"><span class="comment">设置默认文件系统、设置run Configuration的参数: -DHADOOP_USER_NAME=hadoop  </span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line">FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();      </span><br><span class="line">fs = FileSystem.get(conf);</span><br></pre></td></tr></table></figure></li><li><p>在构造函数中设置配置信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方式2:在此方法的参数中设置默认文件系统、用户名</span></span><br><span class="line"><span class="comment">根据配置信息，去获取一个具体文件系统的客户端操作实例对象</span></span><br><span class="line"><span class="comment">会覆盖掉配置文件中读取的值</span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line">FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">conf.set(<span class="string">"fs.defaultFS"</span>, <span class="string">"hdfs://master:9000/"</span>);</span><br><span class="line">fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://master:9000/"</span>), conf, <span class="string">"hadoop"</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="FileSystem操作实例"><a href="#FileSystem操作实例" class="headerlink" title="FileSystem操作实例"></a>FileSystem操作实例</h3><p>项目新建完成，先来测试从hdfs上下载文件，从hdfs中将 jdk-7u65-linux-i586.tar.gz 下载到本地<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zqinsheng.hdfs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FSDataInputStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HdfsUtil</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//hdfs的配置信息,上述的两种配置方式,这里采用第一种</span></span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line"><span class="comment">//根据配置信息，去获取一个具体文件系统的客户端操作实例</span></span><br><span class="line">FileSystem fs = FileSystem.get(conf);</span><br><span class="line"><span class="comment">//hdfs文件存放的路径</span></span><br><span class="line">Path path = <span class="keyword">new</span> Path(<span class="string">"hdfs://master:9000/jdk-7u65-linux-i586.tar.gz"</span>);</span><br><span class="line"><span class="comment">//通过一个输入流获取将要下载的文件</span></span><br><span class="line">FSDataInputStream is = fs.open(path);</span><br><span class="line"><span class="comment">//通过一个输出流指定下载到哪</span></span><br><span class="line">FileOutputStream out = <span class="keyword">new</span> FileOutputStream(<span class="string">"h:\\download.jar"</span>);</span><br><span class="line"><span class="comment">//commons包中提供的工具类,将一个输入流拷贝到输出流中</span></span><br><span class="line">IOUtils.copy(is, out);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也许会出现这样的错误，原因是java不认识hdfs://这样的路径，本地文件系统不知道这是什么路径，一般都是<strong>配置文件</strong>的问题，请检查是否将 <code>core-site.xml、hdfs-site.xml</code>文件拷贝到src目录下，或是检查配置参数。<br><img src="http://wx2.sinaimg.cn/large/005TBZ5oly1fo4swh96k2j30zq07xq3w.jpg" alt="">   </p><p>或者是这样的错误，权限被拒绝，原因还是在windows中我们的用户不是hdfs所指定的用户，如果在Linux中使用eclipse则不会出现这样的情况。</p><p><img src="http://wx2.sinaimg.cn/large/005TBZ5oly1fo5xyyhyvgj30zf0fnjt1.jpg" alt=""></p><p>解决办法：</p><ul><li><p>可以在run as-&gt;run<br>configuration-&gt;arguments里面添加-DHADOOP_USER_NAME=用户名  </p></li><li><p>或者是通过FileSystem.get()进行user的指定，fs = FileSystem.get(new URI(“hdfs://master:9000/“), conf, “hadoop”);</p></li></ul><p>上面的下载文件是一种相对底层的写法，<strong>FileSystem</strong> 已经帮我们将这些操作封装好了，我们直接调用这些方法即可完成相对应的操作。通过一个<strong>Unit</strong>测试代码来看一下封装好的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zqinsheng.hdfs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.URI;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.FileSystem;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.LocatedFileStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.Path;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.fs.RemoteIterator;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHdfs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">FileSystem fs = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次执行方法前都获取FileSystem实例对象</span></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> IOException, Exception, Exception </span>&#123;</span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">fs = FileSystem.get(<span class="keyword">new</span> URI(<span class="string">"hdfs://master:9000"</span>), conf, <span class="string">"hadoop"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上传文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">upload</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IOException </span>&#123;</span><br><span class="line">fs.copyFromLocalFile(<span class="keyword">new</span> Path(<span class="string">"f://HelloWorld.txt"</span>), <span class="keyword">new</span> Path(<span class="string">"hdfs://master:9000/testHdfs"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果报空指针异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 解决方法:将fs.copyToLocalFile(hdfsPath,localPath);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 改为fs.copyToLocalFile(false,hdfsPath,localPath,true);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> <span class="keyword">throws</span> Exception, IOException </span>&#123;</span><br><span class="line">fs.copyToLocalFile(<span class="keyword">new</span> Path(<span class="string">"hdfs://master:9000/testHdfs/HelloWorld.txt"</span>), <span class="keyword">new</span> Path(<span class="string">"h:/HelloWorld.txt"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mkdir</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, IOException </span>&#123;</span><br><span class="line">fs.mkdirs(<span class="keyword">new</span> Path(<span class="string">"hdfs://master:9000/aa/bb/cc"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除文件或文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IllegalArgumentException, IOException </span>&#123;</span><br><span class="line">fs.delete(<span class="keyword">new</span> Path(<span class="string">"hdfs://master:9000/aa"</span>),<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定目录下的文件，不包括文件夹，包括子文件夹下的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFile</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IllegalArgumentException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//获取到文件状态的迭代器,true表示递归遍历</span></span><br><span class="line">RemoteIterator&lt;LocatedFileStatus&gt; files = fs.listFiles(<span class="keyword">new</span> Path(<span class="string">"hdfs://master:9000/"</span>),<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">//遍历迭代器</span></span><br><span class="line"><span class="keyword">while</span>(files.hasNext()) &#123;</span><br><span class="line"><span class="comment">//得到每个文件状态</span></span><br><span class="line">LocatedFileStatus file = files.next();</span><br><span class="line"><span class="comment">//拿到LocatedFileStatus对象后，可以通过这个对象获取文件的名称、路径、块大小、权限、所属者等等信息</span></span><br><span class="line">String name = file.getPath().getName();</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询指定目录下的文件和文件夹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> FileNotFoundException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listFileAndDir</span><span class="params">()</span> <span class="keyword">throws</span> FileNotFoundException, IllegalArgumentException, Exception </span>&#123;</span><br><span class="line"><span class="comment">//列出文件或文件夹信息，不提供递归遍历</span></span><br><span class="line"><span class="comment">//得到文件的状态</span></span><br><span class="line">FileStatus[] listStatus = fs.listStatus(<span class="keyword">new</span> Path(<span class="string">"hdfs://master:9000/"</span>));</span><br><span class="line"><span class="keyword">for</span>(FileStatus fileStatus:listStatus) &#123;</span><br><span class="line"><span class="comment">//获取文件名称</span></span><br><span class="line">String name = fileStatus.getPath().getName();</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HDFS的JAVA客户端编写&quot;&gt;&lt;a href=&quot;#HDFS的JAVA客户端编写&quot; class=&quot;headerlink&quot; title=&quot;HDFS的JAVA客户端编写&quot;&gt;&lt;/a&gt;HDFS的JAVA客户端编写&lt;/h1&gt;&lt;p&gt;之前一直使用 HDFS Shell 命令来完成对 HDFS 的操作，当然也可以使用 Java 来对 HDFS 实现操作。&lt;br&gt;接下来通过一些例子来看一下 JAVA 是如何对 HDFS 实现操作的。  &lt;/p&gt;
&lt;h3 id=&quot;在eclipse中新建一个java项目&quot;&gt;&lt;a href=&quot;#在eclipse中新建一个java项目&quot; class=&quot;headerlink&quot; title=&quot;在eclipse中新建一个java项目&quot;&gt;&lt;/a&gt;在eclipse中新建一个java项目&lt;/h3&gt;&lt;p&gt;将Linux中hadoop安装目录下，配置好的&lt;code&gt;core-site.xml&lt;/code&gt; &lt;code&gt;hdfs-site.xml&lt;/code&gt;，mapred-site.xml，yarn-site.xml都拷贝到eclipse工作空间&lt;br&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/large/005TBZ5oly1fo4ufraku9j309c05t0sq.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>hdfs&amp;mapreduce测试之wordCount</title>
    <link href="https://zqinsheng.github.io/2018/01/18/03_hdfs&amp;mapreduce%E6%B5%8B%E8%AF%95%E4%B9%8BwordCount/"/>
    <id>https://zqinsheng.github.io/2018/01/18/03_hdfs&amp;mapreduce测试之wordCount/</id>
    <published>2018-01-17T17:35:34.000Z</published>
    <updated>2018-08-14T18:56:34.413Z</updated>
    
    <content type="html"><![CDATA[<p>环境搭建完成，hadoop正常启动。按照国际惯例，通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个Hello World级别的程序就是词频统计WordCount！</p><h2 id="一、测试HDFS"><a href="#一、测试HDFS" class="headerlink" title="一、测试HDFS"></a>一、测试HDFS</h2><p>hadoop启动成功后，首先通过<code>http://主机地址:50070</code>到web界面，查看一下HDFS中的文件，找到菜单栏 Browse the file system<br><img src="http://wx2.sinaimg.cn/large/005TBZ5oly1fnnk2dnae9j30mw0363ye.jpg" alt=""><br><a id="more"></a><br>进入之后，可以看到根目录 / 下面没任何文件，可以通过<code>hadoop fs -put &lt;linux上的文件&gt; &lt;hdfs上的路径&gt;</code>上传一个文件到hdfs文件系统中，这里先上传一个文件感受一下。  </p><p>上传jdk到hdfs根目录下<code>hadoop fs -put jdk-7u65-linux-i586.tar.gz hdfs://master:9000/</code><br><img src="http://wx4.sinaimg.cn/large/005TBZ5oly1fnnleok1cjj311u09adg3.jpg" alt=""></p><p>上传成功，可以看到文件的基本信息。hdfs可以上传文件，同样可以下载文件，web界面通过点击文件名下载到本地windows。<br>Linux通过<code>hadoop fs -get &lt;hdfs上的路径&gt; &lt;linux路径&gt;</code>  </p><p>下载jdk到本地 /home/hadoop 目录下<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@master ~]$ pwd</span><br><span class="line">/home/hadoop</span><br><span class="line">[hadoop@master ~]$ ll</span><br><span class="line">total 8</span><br><span class="line">drwxrwxr-x. 4 hadoop hadoop 4096 Jan 20 01:49 tmp</span><br><span class="line">drwxrwxr-x. 4 hadoop hadoop 4096 Jan 21 01:48 tools</span><br><span class="line">[hadoop@master ~]$ hadoop fs -get hdfs://master:9000/jdk-7u65-linux-i586.tar.gz /home/hadoop/</span><br><span class="line">[hadoop@master ~]$ ll</span><br><span class="line">total 140232</span><br><span class="line">-rw-r--r--. 1 hadoop hadoop 143588167 Jan 21 01:51 jdk-7u65-linux-i586.tar.gz</span><br><span class="line">drwxrwxr-x. 4 hadoop hadoop      4096 Jan 20 01:49 tmp</span><br><span class="line">drwxrwxr-x. 4 hadoop hadoop      4096 Jan 21 01:48 tools</span><br></pre></td></tr></table></figure></p><p>看到成功下载jdk到本地，表示hdfs正常工作，接下来测试一下mapreduce  </p><h2 id="二、测试MapReduce"><a href="#二、测试MapReduce" class="headerlink" title="二、测试MapReduce"></a>二、测试MapReduce</h2><p>测试 MapReduce 要通过写一些程序测试，这里可以先通过 hadoop 自带的一些例子程序来测试。<br>这些例子程序在<code>hadoop安装目录/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.x.x.jar</code>中，这个jar包里面有一些例子程序，其中就包含统计词频的 <strong>WordCount</strong>  </p><p>接下来就通过WordCount来实现一个小例子  </p><ul><li><p>新建一个文件testCount.txt，输入一些单词：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@master mapreduce]$ vi testCount.txt</span><br><span class="line">hello world</span><br><span class="line">hello hadoop</span><br><span class="line">hello hdfs</span><br><span class="line">hello mapreduce</span><br><span class="line">hello yarn</span><br></pre></td></tr></table></figure></li><li><p>mapreduce是在集群上面运行，所以数据也要放到集群上面<br>将testCount.txt上传到hdfs中，为了方便，在根目录下新建一个文件夹 wordcount/input 来存放数据</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@master mapreduce]$ hadoop fs -mkdir hdfs://master:9000/wordcount</span><br><span class="line">[hadoop@master mapreduce]$ hadoop fs -mkdir hdfs://master:9000/wordcount/input</span><br><span class="line">```   </span><br><span class="line">可以通过web界面查看文件夹&lt;/br&gt;</span><br><span class="line">![](http://wx2.sinaimg.cn/large/005TBZ5oly1fnnnxthe1yj30zn08tglt.jpg)&lt;/br&gt;  </span><br><span class="line"></span><br><span class="line">* 上传testCount.txt到input文件夹中:  </span><br><span class="line">``[hadoop@master mapreduce]$ hadoop fs -put testCount.txt /wordcount/input``  </span><br><span class="line"></span><br><span class="line">* 运行 hadoop-mapreduce-examples.jar中的wordcount程序，注意wordcount后面要跟两个参数，**/wordcount/input** 数据输入源，  **/wordcount/output** 数据输出文件夹，运行成功后数据输出的地方，可自定义位置  </span><br><span class="line">``hadoop jar hadoop-mapreduce-examples-2.4.1.jar wordcount /wordcount/input /wordcount/output``  </span><br><span class="line">```shell</span><br><span class="line">18/01/21 03:26:20 INFO mapreduce.Job:  map 0% reduce 0%</span><br><span class="line">18/01/21 03:26:27 INFO mapreduce.Job:  map 100% reduce 0%</span><br><span class="line">18/01/21 03:26:33 INFO mapreduce.Job:  map 100% reduce 100%</span><br><span class="line">18/01/21 03:26:34 INFO mapreduce.Job: Job job_1516452484789_0003 completed successfully</span><br><span class="line">18/01/21 03:26:34 INFO mapreduce.Job: Counters: 49</span><br><span class="line">```  </span><br><span class="line">运行成功后，查看输出文件夹，里面多了两个文件  </span><br><span class="line">```shell</span><br><span class="line">[hadoop@master mapreduce]$ hadoop fs -ls /wordcount/output</span><br><span class="line">Found 2 items</span><br><span class="line">-rw-r--r--   1 hadoop supergroup          0 2018-01-21 03:26 /wordcount/output/_SUCCESS</span><br><span class="line">-rw-r--r--   1 hadoop supergroup         51 2018-01-21 03:26 /wordcount/output/part-r-00000</span><br></pre></td></tr></table></figure><p>查看输出的文件内容<br><code>hadoop fs -cat /wordcount/output/part-r-00000</code></p><pre><code class="shell">/wordcount/output/part-r-00000hadoop  1hdfs    1hello   5mapreduce       1world   1yarn    1</code></pre><p>成功统计出每个单词出现的次数！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;环境搭建完成，hadoop正常启动。按照国际惯例，通常我们在学习一门语言的时候，写的第一个程序就是Hello World。而在学习Hadoop时，我们要写的第一个Hello World级别的程序就是词频统计WordCount！&lt;/p&gt;
&lt;h2 id=&quot;一、测试HDFS&quot;&gt;&lt;a href=&quot;#一、测试HDFS&quot; class=&quot;headerlink&quot; title=&quot;一、测试HDFS&quot;&gt;&lt;/a&gt;一、测试HDFS&lt;/h2&gt;&lt;p&gt;hadoop启动成功后，首先通过&lt;code&gt;http://主机地址:50070&lt;/code&gt;到web界面，查看一下HDFS中的文件，找到菜单栏 Browse the file system&lt;br&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/large/005TBZ5oly1fnnk2dnae9j30mw0363ye.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>ssh免密登陆</title>
    <link href="https://zqinsheng.github.io/2018/01/10/02_ssh%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/"/>
    <id>https://zqinsheng.github.io/2018/01/10/02_ssh免密登陆/</id>
    <published>2018-01-09T16:05:28.000Z</published>
    <updated>2018-08-14T18:56:23.302Z</updated>
    
    <content type="html"><![CDATA[<p>在启动和停止hadoop的时候，我们发现需要输入很多次密码，在伪分布式的环境中，就一个节点，一个 NameNode 和几个DataNode，输入几次密码还可以接受，但是如果有1000个节点，这样的操作要重复1000次，这是我们不能接受的。由此我们要使用一种叫做 SSH 的登陆方式来帮助我们免密登陆。  </p><h2 id="一、什么是SSH"><a href="#一、什么是SSH" class="headerlink" title="一、什么是SSH"></a>一、什么是SSH</h2><p>SSH(Secure Shell)是一项创建在应用层和传输层基础上的安全协议，早期互联网通信都是明文通信，一旦被截获将暴露内容。1995年，芬兰研究员Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。  </p><p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。<br>简单的说，SSH就是一种网络协议，用于计算机之间的加密登录。<br><a id="more"></a></p><h2 id="二、hdoop中的SSH免密登陆"><a href="#二、hdoop中的SSH免密登陆" class="headerlink" title="二、hdoop中的SSH免密登陆"></a>二、hdoop中的SSH免密登陆</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>有A和B两台机器</p><ol><li>在A上创建一对密钥对，包括一个公钥和一个私钥 （公钥文件：~/.ssh/id_rsa.pub； 私钥文件：~/.ssh/id_rsa）。</li><li>把A公钥放到B的（~/.ssh/authorized_keys）文件中, 自己保留好私钥.</li><li>在使用ssh登录时,ssh程序会发送A私钥去和B上的A公钥做匹配.如果匹配成功就可以登录了。  </li></ol><p>假设我们有两台机器，A实现SSH免密登陆访问B<br><strong>A.hadoop@master(192.168.2.100)</strong><br><strong>B.hadoop@slave(192.168.2.128)</strong>  </p><p>s<br><strong>第一步：生成密钥对</strong> <code>ssh-keygen -t rsa</code><br>在A机器上生成SSH密钥对，rsa 是加密算法，询问其密码直接回车默认为空，询问保存路径时直接回车采用默认路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">[hadoop@master /]$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/home/hadoop/.ssh/id_rsa):</span><br><span class="line">Enter passphrase (empty for no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved in /home/hadoop/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /home/hadoop/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">2b:42:8e:3d:ab:6e:98:e4:67:81:6c:5b:3d:86:ba:a8 hadoop@master</span><br><span class="line">The key&apos;s randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|. . +   S        |</span><br><span class="line">| = O +   .       |</span><br><span class="line">|+o= B o .        |</span><br><span class="line">|++.o + .         |</span><br><span class="line">|E+*..            |</span><br><span class="line">+-----------------+</span><br><span class="line">```  </span><br><span class="line">一路回车，此时生成的密钥对：id_rsa和id_rsa.pub，会默认存储在&quot;/home/hadoop/.ssh&quot;目录下。    </span><br><span class="line">```shell</span><br><span class="line">/home/hadoop/.ssh</span><br><span class="line">[hadoop@master .ssh]$ ll</span><br><span class="line">total 12</span><br><span class="line">-rw-------. 1 hadoop hadoop 1675 Jan 28 22:35 id_rsa</span><br><span class="line">-rw-r--r--. 1 hadoop hadoop  395 Jan 28 22:35 id_rsa.pub</span><br><span class="line">-rw-r--r--. 1 hadoop hadoop 1188 Jan 28 22:15 known_hosts</span><br><span class="line">[hadoop@master .ssh]$</span><br><span class="line">```  </span><br><span class="line">**第二步：将生成的A公钥远程拷贝到B机器  hadoop@slave(192.168.2.128)**  </span><br><span class="line">拷贝命令：``scp id_rsa.pub slave:/home/hadoop``  </span><br><span class="line"></span><br><span class="line">**第三步：将公钥添加到授权文件&quot;authorized_keys&quot;**  </span><br><span class="line">登陆到B机器，在B机器上将A公钥追加到授权文件中  </span><br><span class="line">``cat id_rsa.pub &gt;&gt; .ssh/authorized_keys``  </span><br><span class="line"></span><br><span class="line">**第四步：修改文件&quot;authorized_keys&quot;权限**  </span><br><span class="line">这一步很重要，否则SSH登陆时仍然需要密码  </span><br><span class="line">``chmod 700 ~/.ssh``  </span><br><span class="line">``chmod 600 authorized_keys``  </span><br><span class="line"></span><br><span class="line">**第五步：修改SSH配置文件**  </span><br><span class="line">``vi /etc/ssh/sshd_config``  </span><br><span class="line"></span><br><span class="line">找到如下三条信息，默认是被注释的，将注释去掉，这三条信息的含义分别是：  </span><br><span class="line">RSAAuthentication yes # 启用 RSA 认证  </span><br><span class="line">PubkeyAuthentication yes # 启用公钥私钥配对认证方式  </span><br><span class="line">AuthorizedKeysFile .ssh/authorized_keys # 公钥文件路径（和authorized_keys文件路径相同）  </span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile     .ssh/authorized_keys</span><br><span class="line">#AuthorizedKeysCommand none</span><br><span class="line">#AuthorizedKeysCommandRunAs nobody</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">**第六步：重启SSH服务**  </span><br><span class="line">```shell</span><br><span class="line">[root@slave .ssh]# service sshd restart</span><br><span class="line">Stopping sshd: [  OK  ]</span><br><span class="line">Starting sshd: [  OK  ]</span><br></pre></td></tr></table></figure></p><p><strong>第七步：验证，在 A机器master上使用 SSH登录 B机器 slave</strong>  </p><pre><code class="Shell">[hadoop@master /]$ ssh slaveLast login: Sun Jan 28 08:33:08 2018 from 192.168.2.100[hadoop@slave ~]$</code></pre><p>到此就OK了，或者第一次需要输入密码，以后再次登陆就不需要输入密码了。如果配置完后每次都要输入密码，大多是因为文件权限的问题，重新检查.ssh文件夹和authorized_keys的访问权限。  </p><h2 id="三、伪分布式集群启动免密"><a href="#三、伪分布式集群启动免密" class="headerlink" title="三、伪分布式集群启动免密"></a>三、伪分布式集群启动免密</h2><p>回到一开始的问题，在启动hadoop集群的时候，我们需要输入很多次密码，用SSH的方式免密登陆，同样的道理，将自己的公钥添加到自己机器的授权文件中即可。<br><code>[hadoop@master .ssh]$ cat id_rsa.pub &gt;&gt; ./authorized_keys</code><br>修改权限：<br><code>[hadoop@master .ssh]$ chmod 600 authorized_keys</code>  </p><p>启动和停止一下hadoop看看，是不是就不用输入密码了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在启动和停止hadoop的时候，我们发现需要输入很多次密码，在伪分布式的环境中，就一个节点，一个 NameNode 和几个DataNode，输入几次密码还可以接受，但是如果有1000个节点，这样的操作要重复1000次，这是我们不能接受的。由此我们要使用一种叫做 SSH 的登陆方式来帮助我们免密登陆。  &lt;/p&gt;
&lt;h2 id=&quot;一、什么是SSH&quot;&gt;&lt;a href=&quot;#一、什么是SSH&quot; class=&quot;headerlink&quot; title=&quot;一、什么是SSH&quot;&gt;&lt;/a&gt;一、什么是SSH&lt;/h2&gt;&lt;p&gt;SSH(Secure Shell)是一项创建在应用层和传输层基础上的安全协议，早期互联网通信都是明文通信，一旦被截获将暴露内容。1995年，芬兰研究员Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。  &lt;/p&gt;
&lt;p&gt;如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。&lt;br&gt;简单的说，SSH就是一种网络协议，用于计算机之间的加密登录。&lt;br&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop伪分布式的搭建</title>
    <link href="https://zqinsheng.github.io/2018/01/01/01_hadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://zqinsheng.github.io/2018/01/01/01_hadoop伪分布式的安装/</id>
    <published>2018-01-01T12:15:38.000Z</published>
    <updated>2019-04-02T12:32:02.049Z</updated>
    
    <content type="html"><![CDATA[<p>网上看了许多教程，参考着<a href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html" target="_blank" rel="noopener">官方文档</a>，按照步骤一步一步来，最后顺利在CentOS中成功安装Hadoop并运行，这里特做一个总结，下面就把详细的安装步骤叙述一下。  </p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>由于本人电脑配置不高，本文所使用的是 CentOS 6.5 32 位作为系统环境,也可以用其他版本的 Linux，例如: Ubuntu。<br>基于 Hadoop2.4.1(stable) 版本，Hadoop2.X.X 同样适用，<br><a id="more"></a><br>hadoop 官网本来提供的都是32位，因为我们服务器中使用的大部分都是64位，所以不得不编译。后来官网从 hadoop2.5 版本开始就提供了64位。请根据自己的 Linux 系统，下载对应的 hadoop 版本，否则64位的 hadoop 运行到32位的Linux上就会出现一些问题，可到<a href="https://archive.apache.org/dist/hadoop/common/" target="_blank" rel="noopener">官方网站</a>下载对应的稳定版本。  </p><h2 id="一、安装JDK"><a href="#一、安装JDK" class="headerlink" title="一、安装JDK"></a>一、安装JDK</h2><p>根据官方说明，Hadoop 版本大于等于2.7：要求 Java7(openjdk/oracle) 或者以上版本，hadoop版本小于等于2.6：要求至少为 Java 6(openjdk/oracle)，我们这里使用JDK1.7。<br>JDK下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a>  </p><ul><li><p><strong>上传JDK到linux中</strong><br>下载完成之后，将JDK上传到Linux中，这里推荐两种上传方式:<br><strong>1.FileZilla</strong>:免费小巧的FTP软件，安装之后功能简单明了，直接用鼠标拖动上传文件。<br><strong>2.SecureCRT</strong>:很好用的远程连接软件，上传文件只需要在SecureCRT连接服务器后，使用快捷键<code>Alt+P</code>打开sftp窗口<br>使用命令<code>put g:/jdk-7u65-linux-i586.tar.gz</code>(上传文件所在的路径)<br>个人喜欢使用第二种方式，一条命令搞定。  </p></li><li><p><strong>安装</strong><br>上传完成之后，在 hadoop 这个用户目录创建一个tools文件夹来专门管理文件（/home/hadoop/tools/），使用 命令<code>tar -zxvf</code>将JDK解压到tools文件夹中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf jdk-7u65-linux-i586.tar.gz -C tools/</span><br></pre></td></tr></table></figure></li></ul><p>解压完成，进入jdk1.7.0_65/bin看到我们熟悉的java命令则安装成功</p><ul><li><strong>配置java的环境变量</strong><br>为了方便我们在系统中使用java命令，需要将/bin目录添加到环境变量中，使用命令：<br><code>vi /etc/profile</code><br>在最后一行加入：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/hadoop/tools/jdk1.7.0_65</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure></li></ul><p>保存之后，刷新配置让其更改生效：<code>source /etc/profile</code><br>在/bin文件夹外面使用<code>java -version</code>能看到版本信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version <span class="string">"1.7.0_65"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_65-b17)</span><br><span class="line">Java HotSpot(TM) Client VM (build 24.65-b04, mixed mode)</span><br></pre></td></tr></table></figure></p><p>到此为止，Java已经安装完成。  </p><h2 id="二、安装Hadoop"><a href="#二、安装Hadoop" class="headerlink" title="二、安装Hadoop"></a>二、安装Hadoop</h2><p>使用上传JDK的方式将hadoop上传到Linux中<br>安装方式与安装jdk同理，解压到tools文件夹中即可：<br><code>tar -zxvf hadoop-2.4.1.tar.gz -C tools/</code>  </p><ul><li><p><strong>配置hadoop的环境变量</strong><br>在 JAVA_HOME 之后加入 hadoop的 /bin 和 /sbin<br><code>vi /etc/profile</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/hadoop/tools/jdk1.7.0_65</span><br><span class="line">export HADOOP_HOME=/home/hadoop/tools/hadoop-2.4.1</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure></li><li><p><strong>修改hadoop配置文件</strong><br>解压完成后开始修改hadoop的配置文件<br>配置文件位于<code>/hadoop-x.x.x/etc/hadoop</code>目录下<br>更改如下5个配置文件：  </p></li></ul><p>1.<code>vi hadoop-env.sh</code><br>hadoop 环境变量脚本文件 hadoop-env.sh<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/home/hadoop/tools/jdk1.7.0_65</span><br></pre></td></tr></table></figure></p><p>注意这里一定要是java的绝对路径，不可以用$JAVA_HOME代替。  </p><p>2.<code>vi core-site.xml</code><br>hadoop 核心配置文件 core-site.xml<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">      &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">      &lt;value&gt;hdfs://master:9000&lt;/value&gt;         </span><br><span class="line">    &lt;/property&gt;  </span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/home/hadoop/tmp&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>这里的<value>hdfs://master:9000</value> ：master表示主机名，默认是localhost（也可以是IP地址），默认端口是9000。/home/hadoop/tmp为hadooop运行临时文件的目录，自己合理选择文件夹。  </p><p>3.<code>vi hdfs-site.xml</code><br>hdfs 配置文件 hdfs-site.xml<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>指定HDFS副本的数量  </p><p>4.<code>vi mapred-site.xml</code><br>MapReduce 配置文件 mapred-site.xml<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;mapreduce.framework.name&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;yarn&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p><p>5.<code>vi yarn-site.xml</code><br>yarn配置文件yarn-site.xml<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;property&gt;                                                       </span><br><span class="line">    &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;master&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;property&gt;</span><br><span class="line">    &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;mapreduce_shuffle&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">```  </span><br><span class="line">指定哪些机器上面要启动namenode，我们这里只有一台机器，先加入本机的主机名,如果有多台机器,在后面依次添加主机名  </span><br><span class="line">最后修改slaves  ``vi slaves``  </span><br><span class="line">```shell</span><br><span class="line">[hadoop@master hadoop]$ vi slaves</span><br><span class="line">master</span><br></pre></td></tr></table></figure></p><h2 id="三、启动Hadoop"><a href="#三、启动Hadoop" class="headerlink" title="三、启动Hadoop"></a>三、启动Hadoop</h2><p>这里在启动的时候，需要输入几次密码，一直输入密码就行  </p><p>1.格式化HDFS文件系统，对NameNode进行初始化<br><code>hdfs namenode -format</code>  </p><p>2.启动HDFS (启动NameNode和DataNode守护进程)<br><code>sbin/start-dfs.sh</code>  </p><p>3.启动YARN (启动ResourceManager 和 NodeManager 守护进程)<br><code>sbin/start-yarn.sh</code>  </p><p>4.验证是否启动成功，查看进程命令： <code>jps</code><br>如看到以下进程，则表示hadoop正常启动  </p><pre><code class="shell">3039 ResourceManager2745 DataNode2885 SecondaryNameNode3311 NodeManager2634 NameNode3351 Jps</code></pre><p>启动成功后，可以在浏览器中输入<code>http://主机地址:50070</code>访问web界面，查看 NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。我这里通过主机名 master 访问(需要修改windows中hosts文件主机名对应的ip)，或者通过主机的ip地址也可以访问。  </p><p><img src="http://wx3.sinaimg.cn/large/005TBZ5oly1fnndaj82y2j30xe0iy755.jpg" alt="">  </p><p>界面查看任务的运行情况：<code>http://主机地址:8088</code>  </p><p><img src="http://wx3.sinaimg.cn/large/005TBZ5oly1fnndrg8y6rj311s0cswfx.jpg" alt="">  </p><p>至此，Hadoop伪分布式已成功搭建，下面来解决启动的时候输入很多次密码的问题,使用SSH的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上看了许多教程，参考着&lt;a href=&quot;http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/SingleCluster.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方文档&lt;/a&gt;，按照步骤一步一步来，最后顺利在CentOS中成功安装Hadoop并运行，这里特做一个总结，下面就把详细的安装步骤叙述一下。  &lt;/p&gt;
&lt;h2 id=&quot;安装环境&quot;&gt;&lt;a href=&quot;#安装环境&quot; class=&quot;headerlink&quot; title=&quot;安装环境&quot;&gt;&lt;/a&gt;安装环境&lt;/h2&gt;&lt;p&gt;由于本人电脑配置不高，本文所使用的是 CentOS 6.5 32 位作为系统环境,也可以用其他版本的 Linux，例如: Ubuntu。&lt;br&gt;基于 Hadoop2.4.1(stable) 版本，Hadoop2.X.X 同样适用，&lt;br&gt;
    
    </summary>
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="https://zqinsheng.github.io/tags/hadoop/"/>
    
  </entry>
  
  <entry>
    <title>End of the 2017</title>
    <link href="https://zqinsheng.github.io/2017/12/31/Goodbye-2017,looking-ahead-to-2018/"/>
    <id>https://zqinsheng.github.io/2017/12/31/Goodbye-2017,looking-ahead-to-2018/</id>
    <published>2017-12-31T10:14:08.000Z</published>
    <updated>2018-01-28T07:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<!--sadf--><a id="more"></a><p>Goodbye 2017, looking ahead to 2018</p><p>时光如青春一般飞逝，2017悄然无声已结束，新年的钟声即将敲响</p><p>这一年，没有生活波澜的澎湃汹涌与大风大浪，但也不少阴沟翻船</p><p>无处安放的青春必将在经历许多磨难与挣扎后得到绽放</p><p>2018:新的开始，新的学习，新的挑战。</p>]]></content>
    
    <summary type="html">
    
      &lt;!--sadf--&gt;
    
    </summary>
    
      <category term="生活随笔" scheme="https://zqinsheng.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活随笔" scheme="https://zqinsheng.github.io/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
